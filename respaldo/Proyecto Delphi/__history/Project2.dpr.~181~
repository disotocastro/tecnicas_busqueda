program Metodos_Busqueda;

{$APPTYPE CONSOLE}

uses
  SysUtils,
  Classes,
  Mochila; // Asumiendo que todos los procedimientos y funciones se movieron aquí


{ MENU MOCHILA }
procedure ProblemaMochila;
var
  MochilaMaxPeso, i: Integer;
  peso, beneficio: array of Integer;
  Lista: TStringList;
  opcionMenu: Integer;
  Objetos: array of TObjeto;
begin
  // Solicitar el peso máximo de la mochila
  Write('Ingresa el peso máximo de la mochila: ');
  Readln(MochilaMaxPeso);

  // Leer y almacenar los pesos
  Lista := LeerDatos('Ingresa por favor el arreglo de pesos (ejemplo: 1 2 3 4 5): ');
  try
    SetLength(peso, Lista.Count);
    for i := 0 to Lista.Count - 1 do
      peso[i] := StrToInt(Lista[i]);
  finally
    Lista.Free;
  end;

  // Leer y almacenar los beneficios
  Lista := LeerDatos('Ingresa por favor el arreglo de beneficios (ejemplo: 1 2 3 4 5): ');
  try
    SetLength(beneficio, Lista.Count);
    for i := 0 to Lista.Count - 1 do
      beneficio[i] := StrToInt(Lista[i]);
  finally
    Lista.Free;
  end;

  // Imprimir los arrays de Pesos y Beneficios
  ImprimirArrays(peso, beneficio);
  Readln;

  // Crear y llenar el array de TObjeto
  SetLength(Objetos, Length(peso));
  for i := 0 to High(Objetos) do
  begin
    Objetos[i].Peso := peso[i];
    Objetos[i].Beneficio := beneficio[i];
  end;

  while True do
  begin
    // Imprimir el menú
    WriteLn('');
    WriteLn('Selecciona el algoritmo de búsqueda:');
    WriteLn('1 - Greedy');
    WriteLn('2 - Fuerza bruta (Exhaustiva pura)');
    WriteLn('3 - Backtracking (Búsqueda Exhaustiva con Ramificación y Acotamiento)');
    WriteLn('4 - Salir');
    Write('Opción: ');
    ReadLn(opcionMenu);
    WriteLn('');

    case opcionMenu of
      1: Greedy(MochilaMaxPeso, Objetos);
      2: FuerzaBruta(MochilaMaxPeso, Objetos);
      3: Backtracking(MochilaMaxPeso, Objetos);
      4: Break;  // Rompe el bucle while, saliendo del programa
    else
      WriteLn('Opción no válida.');
    end;
  end;
  ReadLn;
end;

procedure ProblemaAsignacion;
begin
  // Placeholder para la lógica de asignación 1 a 1
  WriteLn('Problema de asignación 1 a 1 aún no implementado.');
end;

procedure ProblemaDistribucion;
begin
  // Placeholder para la lógica de distribución de recursos
  WriteLn('Problema de distribución de recursos aún no implementado.');
end;

procedure ProblemaVendedor;
begin
  // Placeholder para la lógica del problema del vendedor
  WriteLn('Problema del vendedor aún no implementado.');
end;

var
  opcionMenu: Char;

begin
  repeat
    WriteLn('Selecciona el problema a resolver:');
    WriteLn('a) Problema de asignación 1 a 1');
    WriteLn('b) Problema de distribución de un recurso');
    WriteLn('c) Problema de la mochila');
    WriteLn('d) Problema del vendedor');
    WriteLn('e) Salir');
    Write('Opción: ');
    ReadLn(opcionMenu);

    case opcionMenu of
      'a': ProblemaAsignacion;
      'b': ProblemaDistribucion;
      'c': ProblemaMochila;
      'd': ProblemaVendedor;
      'e': WriteLn('Saliendo del programa...');
    else
      WriteLn('Opción no válida. Intente de nuevo.');
    end;

  until opcionMenu = 'e';
end.

